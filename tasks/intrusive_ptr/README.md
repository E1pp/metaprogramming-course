Интрузивный указатель
========================

## Подготовка

Вспомните или узнайте, что такое [CRTP](https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern). Изучите гарантии [`std::shared_ptr`](https://en.cppreference.com/w/cpp/memory/shared_ptr) в однопоточном сценарии и требования концепта [`std::regular`](https://en.cppreference.com/w/cpp/concepts/regular).

## Задача

Реализуйте `IntrusivePtr<T>` для однопоточной программы. Основное отличие от `std::shared_ptr` заключается в интрузивном подсчете ссылок -- контрольный блок должен лежать прямо в самом объекте `T`. Чтобы достичь подобной оптимизации, имплементатору класса `T` предлагается наследоваться от специальной базы, `RefCountedBase<T>`, а для бОльшей безопасности работы с такими указателями, объекты предлагается аллоцировать с помощью специальной функции `New<T>`:
```cpp
class MyClass
	: public RefCountedBase<MyClass>
{
public:
	MyClass(int value);
};

IntrusivePtr<MyClass> ptr = New<MyClass>(42);
```
Для обычных указателей корректно определены операции [`static_cast`](https://en.cppreference.com/w/cpp/language/static_cast) и [`dynamic_cast`](https://en.cppreference.com/w/cpp/language/dynamic_cast). Реализуйте функции `StaticPointerCast` и `DynamicPointerCast`, выполняющие те же действия соответственно.

База `RefCountedBase<T>` является полностью сконструированной к моменту начала тела конструктора самого `T`, поэтому операции `Ref`/`Unref` должны корректно работать даже там (например, класс может хотеть отдать на себя указатель какому-то другому объекту).

Функция `operator->` должна работать как у обычного указателя -- через нее мужно мочь дотянуться до полей/функций-членов самого `T`.

Использование `IntrusivePtr` не должно ломать alignment объекта -- он может увеличиться, но обязан не уменьшиться.

### Бонус: Неинтрузивный `IntrusivePtr`

Решив задачу, у вас наверняка остался некоторый оверхед в случае иерархий классов -- здесь вы сможете от него избавиться!

Научите `New` создавать `IntrusivePtr` от типов, которые не наследуются от `RefCountedBase`, например, `int`. Полученный метод должен **полностью** сохранять гарантии `IntrusivePtr`, которые вы имели ранее, в частности, ровно 1 аллокацию внутри `New`. Подобное расширение контракта полезно, когда у вас имеется какой-то код из внешних библиотек, который вы не хотите или не можете пропатчить. Дополнительно потребуем, чтобы подобная фича была **opt-in** -- где-то (в вашем случае -- это файл `legacy.h`) нужно написать специальный код, обеспечивающий поддержку `IntrusivePtr` только от выбранных типов, но не от всего подряд.

### Бонус: `WeakPtr`

Реализуйте аналог [`std::weak_ptr`](https://en.cppreference.com/w/cpp/memory/weak_ptr). Обратите внимание на нетривиальную гарантию: в случае однопоточной программы, если `std::weak_ptr::lock` возвращает `nullptr`, объект типа `T` должен быть уже разрушен. В рамках данного бонусного уровня поддержите эту гарантию.

## Формальности
**Баллы**: 200 + 100 + 100
Код пушьте в ветку `intrusive_ptr` и делайте pull requrest в `master`. 

Набор шаблонных аргументов и публичное Апи `RefCountedBase`, `IntrusivePtr`, `WeakPtr` менять запрещено. Других ограничений нет. 